<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc (13.0.1) on Wed Jul 15 10:47:57 CEST 2020 -->
<title>Graph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2020-07-15">
<meta name="description" content="declaration: package: org.graphstream.graph, interface: Graph">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":18,"i1":18,"i2":18,"i3":18,"i4":18,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":18,"i22":18,"i23":18,"i24":18,"i25":18,"i26":18,"i27":6,"i28":6,"i29":18,"i30":18,"i31":6,"i32":6,"i33":6,"i34":6,"i35":6,"i36":6,"i37":18,"i38":18};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Graph.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.graphstream.graph</a></div>
<h1 title="Interface Graph" class="title">Interface Graph</h1>
</div>
<div class="contentContainer">
<section class="description">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream">AttributeSink</a></code>, <code><a href="Element.html" title="interface in org.graphstream.graph">Element</a></code>, <code><a href="../stream/ElementSink.html" title="interface in org.graphstream.stream">ElementSink</a></code>, <code>java.lang.Iterable&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code>, <code><a href="../stream/Pipe.html" title="interface in org.graphstream.stream">Pipe</a></code>, <code><a href="../stream/Sink.html" title="interface in org.graphstream.stream">Sink</a></code>, <code><a href="../stream/Source.html" title="interface in org.graphstream.stream">Source</a></code>, <code><a href="Structure.html" title="interface in org.graphstream.graph">Structure</a></code></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="implementations/AbstractGraph.html" title="class in org.graphstream.graph.implementations">AbstractGraph</a></code>, <code><a href="implementations/AdjacencyListGraph.html" title="class in org.graphstream.graph.implementations">AdjacencyListGraph</a></code>, <code><a href="implementations/DefaultGraph.html" title="class in org.graphstream.graph.implementations">DefaultGraph</a></code>, <code><a href="../ui/graphicGraph/GraphicGraph.html" title="class in org.graphstream.ui.graphicGraph">GraphicGraph</a></code>, <code><a href="implementations/MultiGraph.html" title="class in org.graphstream.graph.implementations">MultiGraph</a></code>, <code><a href="implementations/SingleGraph.html" title="class in org.graphstream.graph.implementations">SingleGraph</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">Graph</span>
extends <a href="Element.html" title="interface in org.graphstream.graph">Element</a>, <a href="../stream/Pipe.html" title="interface in org.graphstream.stream">Pipe</a>, java.lang.Iterable&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;, <a href="Structure.html" title="interface in org.graphstream.graph">Structure</a></pre>
<div class="block">An Interface that advises general purpose methods for handling graphs.
 <p>
 <p>
 This interface is one of the main interfaces of GraphStream. It defines the
 services provided by a graph structure. Graphs implementations must at least
 implement this interface (but are free to provide more services).
 </p>
 <p>
 <p>
 With <a href="../stream/Source.html" title="interface in org.graphstream.stream"><code>Source</code></a>,
 <a href="../stream/Sink.html" title="interface in org.graphstream.stream"><code>Sink</code></a> and <a href="../stream/Pipe.html" title="interface in org.graphstream.stream"><code>Pipe</code></a>,
 this interface is one of the most important. A graph is a
 <a href="../stream/Pipe.html" title="interface in org.graphstream.stream"><code>Pipe</code></a> that buffers the graph events and present
 the graph structure as it is actually.
 </p>
 <p>
 <p>
 In other words, it allows to browse the graph structure, to explore it, to
 modify it, and to implement algorithms on it. This class can be seen as a
 snapshot of a stream of event at current time.
 </p>
 <p>
 <p>
 With factories (<a href="NodeFactory.html" title="interface in org.graphstream.graph"><code>NodeFactory</code></a>,
 <a href="EdgeFactory.html" title="interface in org.graphstream.graph"><code>EdgeFactory</code></a>), users can define their own models
 of nodes or edges. Problem is that when you define such model, you want to
 access to elements with the valid type, without cast if possible. To improve
 the access to elements in such cases, Graph offers implicit genericity to
 access nodes or edges. The following is an example of an access without
 genericity :
 <p>
 
 <pre>
        Graph g = ... ;
        g.setNodeFactory( new MyNodeFactory() );
  g.addNode("root");

  MyNode n = (MyNode) g.getNode("root");

  for( Node o : g.getEachNode() )
  {
        MyNode node = (MyNode) o;
        // Do something with node
  }
 </pre>
 <p>
 With implicit genericity offers by Graph, this can be done easier:
 <p>
 
 <pre>
  Graph g = ... ;
        g.setNodeFactory( new MyNodeFactory() );
  g.addNode("root");

  MyNode n = g.getNode("root");

  for( MyNode node : g.getEachNode() )
  {
        // Do something with node
  }
 </pre>
 <p>
 </p>
 <p>
 <p>
 Graph elements (nodes and edges) can be accessed using their identifier or
 their index. Each node / edge has a unique string identifier assigned when
 the element is created. Each element has an automatically maintained unique
 index between 0 and <a href="Structure.html#getNodeCount()"><code>Structure.getNodeCount()</code></a> - 1 or <a href="Structure.html#getEdgeCount()"><code>Structure.getEdgeCount()</code></a> -
 1. When a new element is added, its index is <code>getNodeCount() - 1</code>
 or <code>getEdgeCount() - 1</code>. When an element is removed, the element
 with the biggest index takes its place. Unlike identifiers, indices can
 change when the graph is modified, but they are always successive. A loop of
 the form
 <p>
 
 <pre>
 for (int i = 0; i &lt; g.getNodeCount(); i++) {
        Node node = g.getNode(i);
        // Do something with node
 }
 </pre>
 <p>
 will always iterate on all the nodes of <code>g</code>.
 </p></div>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="tableTab" onclick="show(16);">Default Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,int,int)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
int&nbsp;index1,
int&nbsp;index2)</code></th>
<td class="colLast">
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a> but the nodes are identified by
 their indices.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,int,int,boolean)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
int&nbsp;fromIndex,
int&nbsp;toIndex,
boolean&nbsp;directed)</code></th>
<td class="colLast">
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)"><code>addEdge(String, String, String, boolean)</code></a> but the nodes are
 identified by their indices.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
java.lang.String&nbsp;node1,
java.lang.String&nbsp;node2)</code></th>
<td class="colLast">
<div class="block">Adds an undirected edge between nodes.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
java.lang.String&nbsp;from,
java.lang.String&nbsp;to,
boolean&nbsp;directed)</code></th>
<td class="colLast">
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a>, but this edge can be directed
 between the two given nodes.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,org.graphstream.graph.Node,org.graphstream.graph.Node)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node1,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node2)</code></th>
<td class="colLast">
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a> but the node references are
 given instead of node identifiers.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addEdge(java.lang.String,org.graphstream.graph.Node,org.graphstream.graph.Node,boolean)">addEdge</a></span>&#8203;(java.lang.String&nbsp;id,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;from,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;to,
boolean&nbsp;directed)</code></th>
<td class="colLast">
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)"><code>addEdge(String, String, String, boolean)</code></a> but the node
 references are given instead of node identifiers.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addNode(java.lang.String)">addNode</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Add a node in the graph.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>java.lang.Iterable&lt;<a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream">AttributeSink</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#attributeSinks()">attributeSinks</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns an "iterable" of <a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream"><code>AttributeSink</code></a> objects registered to this
 graph.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clear()">clear</a></span>()</code></th>
<td class="colLast">
<div class="block">Empty the graph completely by removing any references to nodes or edges.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view">Viewer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#display()">display</a></span>()</code></th>
<td class="colLast">
<div class="block">Utility method that creates a new graph viewer, and register the graph in it.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view">Viewer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#display(boolean)">display</a></span>&#8203;(boolean&nbsp;autoLayout)</code></th>
<td class="colLast">
<div class="block">Utility method that creates a new graph viewer, and register the graph in it.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="EdgeFactory.html" title="interface in org.graphstream.graph">EdgeFactory</a>&lt;? extends <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#edgeFactory()">edgeFactory</a></span>()</code></th>
<td class="colLast">
<div class="block">The factory used to create edge instances.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>java.lang.Iterable&lt;<a href="../stream/ElementSink.html" title="interface in org.graphstream.stream">ElementSink</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#elementSinks()">elementSinks</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns an "iterable" of <a href="../stream/ElementSink.html" title="interface in org.graphstream.stream"><code>ElementSink</code></a> objects registered to this
 graph.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdge(int)">getEdge</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Get an edge by its index.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdge(java.lang.String)">getEdge</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Get an edge by its identifier.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNode(int)">getNode</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Get a node by its index.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNode(java.lang.String)">getNode</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Get a node by its identifier.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getStep()">getStep</a></span>()</code></th>
<td class="colLast">
<div class="block">The current step.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAutoCreationEnabled()">isAutoCreationEnabled</a></span>()</code></th>
<td class="colLast">
<div class="block">Is the automatic creation of missing elements enabled?.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isStrict()">isStrict</a></span>()</code></th>
<td class="colLast">
<div class="block">Is strict checking enabled?</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="NodeFactory.html" title="interface in org.graphstream.graph">NodeFactory</a>&lt;? extends <a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nodeFactory()">nodeFactory</a></span>()</code></th>
<td class="colLast">
<div class="block">The factory used to create node instances.</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>default void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(java.lang.String)">read</a></span>&#8203;(java.lang.String&nbsp;filename)</code></th>
<td class="colLast">
<div class="block">Utility method to read a graph.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>default void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(org.graphstream.stream.file.FileSource,java.lang.String)">read</a></span>&#8203;(<a href="../stream/file/FileSource.html" title="interface in org.graphstream.stream.file">FileSource</a>&nbsp;input,
java.lang.String&nbsp;filename)</code></th>
<td class="colLast">
<div class="block">Utility method to read a graph using the given reader.</div>
</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(int)">removeEdge</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Removes an edge with a given index.</div>
</td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(int,int)">removeEdge</a></span>&#8203;(int&nbsp;fromIndex,
int&nbsp;toIndex)</code></th>
<td class="colLast">
<div class="block">Removes an edge between two nodes.</div>
</td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(java.lang.String)">removeEdge</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Removes an edge knowing its identifier.</div>
</td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>default <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(java.lang.String,java.lang.String)">removeEdge</a></span>&#8203;(java.lang.String&nbsp;from,
java.lang.String&nbsp;to)</code></th>
<td class="colLast">
<div class="block">Remove an edge given the identifiers of its two endpoints.</div>
</td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(org.graphstream.graph.Edge)">removeEdge</a></span>&#8203;(<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&nbsp;edge)</code></th>
<td class="colLast">
<div class="block">Removes an edge.</div>
</td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeEdge(org.graphstream.graph.Node,org.graphstream.graph.Node)">removeEdge</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node1,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node2)</code></th>
<td class="colLast">
<div class="block">Removes an edge between two nodes.</div>
</td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>default <a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeNode(int)">removeNode</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Removes a node with a given index.</div>
</td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>default <a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeNode(java.lang.String)">removeNode</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Remove a node using its identifier.</div>
</td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code><a href="Node.html" title="interface in org.graphstream.graph">Node</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeNode(org.graphstream.graph.Node)">removeNode</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Removes a node.</div>
</td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setAutoCreate(boolean)">setAutoCreate</a></span>&#8203;(boolean&nbsp;on)</code></th>
<td class="colLast">
<div class="block">Enable or disable the automatic creation of missing elements.</div>
</td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setEdgeFactory(org.graphstream.graph.EdgeFactory)">setEdgeFactory</a></span>&#8203;(<a href="EdgeFactory.html" title="interface in org.graphstream.graph">EdgeFactory</a>&lt;? extends <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;&nbsp;ef)</code></th>
<td class="colLast">
<div class="block">Set the edge factory used to create edges.</div>
</td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNodeFactory(org.graphstream.graph.NodeFactory)">setNodeFactory</a></span>&#8203;(<a href="NodeFactory.html" title="interface in org.graphstream.graph">NodeFactory</a>&lt;? extends <a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;&nbsp;nf)</code></th>
<td class="colLast">
<div class="block">Set the node factory used to create nodes.</div>
</td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setStrict(boolean)">setStrict</a></span>&#8203;(boolean&nbsp;on)</code></th>
<td class="colLast">
<div class="block">Enable or disable strict checking.</div>
</td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#stepBegins(double)">stepBegins</a></span>&#8203;(double&nbsp;time)</code></th>
<td class="colLast">
<div class="block">
 Since dynamic graphs are based on discrete event modifications, the notion of
 step is defined to simulate elapsed time between events.</div>
</td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>default void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.lang.String)">write</a></span>&#8203;(java.lang.String&nbsp;filename)</code></th>
<td class="colLast">
<div class="block">Utility method to write a graph in DGS format to a file.</div>
</td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>default void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(org.graphstream.stream.file.FileSink,java.lang.String)">write</a></span>&#8203;(<a href="../stream/file/FileSink.html" title="interface in org.graphstream.stream.file">FileSink</a>&nbsp;output,
java.lang.String&nbsp;filename)</code></th>
<td class="colLast">
<div class="block">Utility method to write a graph in the chosen format to a file.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.stream.<a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream">AttributeSink</a></h3>
<a id="methods.inherited.from.class.org.graphstream.stream.AttributeSink">
<!--   -->
</a><code><a href="../stream/AttributeSink.html#edgeAttributeAdded(java.lang.String,long,java.lang.String,java.lang.String,java.lang.Object)">edgeAttributeAdded</a>, <a href="../stream/AttributeSink.html#edgeAttributeChanged(java.lang.String,long,java.lang.String,java.lang.String,java.lang.Object,java.lang.Object)">edgeAttributeChanged</a>, <a href="../stream/AttributeSink.html#edgeAttributeRemoved(java.lang.String,long,java.lang.String,java.lang.String)">edgeAttributeRemoved</a>, <a href="../stream/AttributeSink.html#graphAttributeAdded(java.lang.String,long,java.lang.String,java.lang.Object)">graphAttributeAdded</a>, <a href="../stream/AttributeSink.html#graphAttributeChanged(java.lang.String,long,java.lang.String,java.lang.Object,java.lang.Object)">graphAttributeChanged</a>, <a href="../stream/AttributeSink.html#graphAttributeRemoved(java.lang.String,long,java.lang.String)">graphAttributeRemoved</a>, <a href="../stream/AttributeSink.html#nodeAttributeAdded(java.lang.String,long,java.lang.String,java.lang.String,java.lang.Object)">nodeAttributeAdded</a>, <a href="../stream/AttributeSink.html#nodeAttributeChanged(java.lang.String,long,java.lang.String,java.lang.String,java.lang.Object,java.lang.Object)">nodeAttributeChanged</a>, <a href="../stream/AttributeSink.html#nodeAttributeRemoved(java.lang.String,long,java.lang.String,java.lang.String)">nodeAttributeRemoved</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.graph.<a href="Element.html" title="interface in org.graphstream.graph">Element</a></h3>
<a id="methods.inherited.from.class.org.graphstream.graph.Element">
<!--   -->
</a><code><a href="Element.html#attributeKeys()">attributeKeys</a>, <a href="Element.html#clearAttributes()">clearAttributes</a>, <a href="Element.html#getArray(java.lang.String)">getArray</a>, <a href="Element.html#getAttribute(java.lang.String)">getAttribute</a>, <a href="Element.html#getAttribute(java.lang.String,java.lang.Class)">getAttribute</a>, <a href="Element.html#getAttributeCount()">getAttributeCount</a>, <a href="Element.html#getFirstAttributeOf(java.lang.Class,java.lang.String...)">getFirstAttributeOf</a>, <a href="Element.html#getFirstAttributeOf(java.lang.String...)">getFirstAttributeOf</a>, <a href="Element.html#getId()">getId</a>, <a href="Element.html#getIndex()">getIndex</a>, <a href="Element.html#getLabel(java.lang.String)">getLabel</a>, <a href="Element.html#getMap(java.lang.String)">getMap</a>, <a href="Element.html#getNumber(java.lang.String)">getNumber</a>, <a href="Element.html#getVector(java.lang.String)">getVector</a>, <a href="Element.html#hasArray(java.lang.String)">hasArray</a>, <a href="Element.html#hasAttribute(java.lang.String)">hasAttribute</a>, <a href="Element.html#hasAttribute(java.lang.String,java.lang.Class)">hasAttribute</a>, <a href="Element.html#hasLabel(java.lang.String)">hasLabel</a>, <a href="Element.html#hasMap(java.lang.String)">hasMap</a>, <a href="Element.html#hasNumber(java.lang.String)">hasNumber</a>, <a href="Element.html#hasVector(java.lang.String)">hasVector</a>, <a href="Element.html#removeAttribute(java.lang.String)">removeAttribute</a>, <a href="Element.html#setAttribute(java.lang.String,java.lang.Object...)">setAttribute</a>, <a href="Element.html#setAttributes(java.util.Map)">setAttributes</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.stream.<a href="../stream/ElementSink.html" title="interface in org.graphstream.stream">ElementSink</a></h3>
<a id="methods.inherited.from.class.org.graphstream.stream.ElementSink">
<!--   -->
</a><code><a href="../stream/ElementSink.html#edgeAdded(java.lang.String,long,java.lang.String,java.lang.String,java.lang.String,boolean)">edgeAdded</a>, <a href="../stream/ElementSink.html#edgeRemoved(java.lang.String,long,java.lang.String)">edgeRemoved</a>, <a href="../stream/ElementSink.html#graphCleared(java.lang.String,long)">graphCleared</a>, <a href="../stream/ElementSink.html#nodeAdded(java.lang.String,long,java.lang.String)">nodeAdded</a>, <a href="../stream/ElementSink.html#nodeRemoved(java.lang.String,long,java.lang.String)">nodeRemoved</a>, <a href="../stream/ElementSink.html#stepBegins(java.lang.String,long,double)">stepBegins</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;java.lang.Iterable</h3>
<a id="methods.inherited.from.class.java.lang.Iterable">
<!--   -->
</a><code>forEach, iterator, spliterator</code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.stream.<a href="../stream/Source.html" title="interface in org.graphstream.stream">Source</a></h3>
<a id="methods.inherited.from.class.org.graphstream.stream.Source">
<!--   -->
</a><code><a href="../stream/Source.html#addAttributeSink(org.graphstream.stream.AttributeSink)">addAttributeSink</a>, <a href="../stream/Source.html#addElementSink(org.graphstream.stream.ElementSink)">addElementSink</a>, <a href="../stream/Source.html#addSink(org.graphstream.stream.Sink)">addSink</a>, <a href="../stream/Source.html#clearAttributeSinks()">clearAttributeSinks</a>, <a href="../stream/Source.html#clearElementSinks()">clearElementSinks</a>, <a href="../stream/Source.html#clearSinks()">clearSinks</a>, <a href="../stream/Source.html#removeAttributeSink(org.graphstream.stream.AttributeSink)">removeAttributeSink</a>, <a href="../stream/Source.html#removeElementSink(org.graphstream.stream.ElementSink)">removeElementSink</a>, <a href="../stream/Source.html#removeSink(org.graphstream.stream.Sink)">removeSink</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.graph.<a href="Structure.html" title="interface in org.graphstream.graph">Structure</a></h3>
<a id="methods.inherited.from.class.org.graphstream.graph.Structure">
<!--   -->
</a><code><a href="Structure.html#edges()">edges</a>, <a href="Structure.html#getEdgeCount()">getEdgeCount</a>, <a href="Structure.html#getNodeCount()">getNodeCount</a>, <a href="Structure.html#nodes()">nodes</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="getNode(java.lang.String)">getNode</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">getNode</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">Get a node by its identifier. This method is implicitly generic and returns
 something which extends Node. The return type is the one of the left part of
 the assignment. For example, in the following call :
 <p>
 
 <pre>
 ExtendedNode node = graph.getNode(&quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedNode node. If no left part exists, method
 will just return a Node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the node to find.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The searched node or null if not found.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdge(java.lang.String)">getEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">Get an edge by its identifier. This method is implicitly generic and returns
 something which extends Edge. The return type is the one of the left part of
 the assignment. For example, in the following call :
 <p>
 
 <pre>
 ExtendedEdge edge = graph.getEdge(&quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedEdge edge. If no left part exists, method
 will just return an Edge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the edge to find.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The searched edge or null if not found.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nodeFactory()">nodeFactory</a></h3>
<div class="memberSignature"><span class="returnType"><a href="NodeFactory.html" title="interface in org.graphstream.graph">NodeFactory</a>&lt;? extends <a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">nodeFactory</span>()</div>
<div class="block">The factory used to create node instances. The factory can be changed to
 refine the node class generated for this graph.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setNodeFactory(org.graphstream.graph.NodeFactory)"><code>setNodeFactory(NodeFactory)</code></a>, 
<a href="#edgeFactory()"><code>edgeFactory()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="edgeFactory()">edgeFactory</a></h3>
<div class="memberSignature"><span class="returnType"><a href="EdgeFactory.html" title="interface in org.graphstream.graph">EdgeFactory</a>&lt;? extends <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</span>&nbsp;<span class="memberName">edgeFactory</span>()</div>
<div class="block">The factory used to create edge instances. The factory can be changed to
 refine the edge class generated for this graph.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setEdgeFactory(org.graphstream.graph.EdgeFactory)"><code>setEdgeFactory(EdgeFactory)</code></a>, 
<a href="#nodeFactory()"><code>nodeFactory()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isStrict()">isStrict</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">isStrict</span>()</div>
<div class="block">Is strict checking enabled? If strict checking is enabled the graph checks
 for name space conflicts (e.g. insertion of two nodes with the same name),
 removal of non-existing elements, use of non existing elements (create an
 edge between two non existing nodes). Graph implementations are free to
 respect strict checking or not.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if enabled.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isAutoCreationEnabled()">isAutoCreationEnabled</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">isAutoCreationEnabled</span>()</div>
<div class="block">Is the automatic creation of missing elements enabled?. If strict checking is
 disabled and auto-creation is enabled, when an edge is created and one or two
 of its nodes are not already present in the graph, the nodes are
 automatically created.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if enabled.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getStep()">getStep</a></h3>
<div class="memberSignature"><span class="returnType">double</span>&nbsp;<span class="memberName">getStep</span>()</div>
<div class="block">The current step.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The step.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="setNodeFactory(org.graphstream.graph.NodeFactory)">setNodeFactory</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">setNodeFactory</span>&#8203;(<span class="arguments"><a href="NodeFactory.html" title="interface in org.graphstream.graph">NodeFactory</a>&lt;? extends <a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;&nbsp;nf)</span></div>
<div class="block">Set the node factory used to create nodes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nf</code> - the new NodeFactory</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="setEdgeFactory(org.graphstream.graph.EdgeFactory)">setEdgeFactory</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">setEdgeFactory</span>&#8203;(<span class="arguments"><a href="EdgeFactory.html" title="interface in org.graphstream.graph">EdgeFactory</a>&lt;? extends <a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;&nbsp;ef)</span></div>
<div class="block">Set the edge factory used to create edges.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ef</code> - the new EdgeFactory</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="setStrict(boolean)">setStrict</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">setStrict</span>&#8203;(<span class="arguments">boolean&nbsp;on)</span></div>
<div class="block">Enable or disable strict checking.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>on</code> - True or false.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isStrict()"><code>isStrict()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="setAutoCreate(boolean)">setAutoCreate</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">setAutoCreate</span>&#8203;(<span class="arguments">boolean&nbsp;on)</span></div>
<div class="block">Enable or disable the automatic creation of missing elements.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>on</code> - True or false.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isAutoCreationEnabled()"><code>isAutoCreationEnabled()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="clear()">clear</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">clear</span>()</div>
<div class="block">Empty the graph completely by removing any references to nodes or edges.
 Every attribute is also removed. However, listeners are kept.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../stream/Source.html#clearSinks()"><code>Source.clearSinks()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addNode(java.lang.String)">addNode</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">addNode</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span>
      throws <span class="exceptions"><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></span></div>
<div class="block">Add a node in the graph.
 <p>
 This acts as a factory, creating the node instance automatically (and
 eventually using the node factory provided). An event is generated toward the
 listeners. If strict checking is enabled, and a node already exists with this
 identifier, an <a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph"><code>IdAlreadyInUseException</code></a> is
 raised. Else the error is silently ignored and the already existing node is
 returned.
 </p>
 <p>
 This method is implicitly generic and returns something which extends Node.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedNode n = graph.addNode(&quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedNode. If no left part exists, method will
 just return a Node.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Arbitrary and unique string identifying the node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The created node (or the already existing node).</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If strict checking is enabled the identifier is already used.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,java.lang.String,java.lang.String)">addEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
java.lang.String&nbsp;node1,
java.lang.String&nbsp;node2)</span>
              throws <span class="exceptions"><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Adds an undirected edge between nodes.
 <p>
 <p>
 The behavior of this method depends on many conditions. It can be summarized
 as follows.
 </p>
 <p>
 <p>
 First of all, the method checks if the graph already contains an edge with
 the same id. If this is the case and strict checking is enabled,
 <code>IdAlreadyInUseException</code> is thrown. If the strict checking is disabled
 the method returns a reference to the existing edge if it has endpoints
 <code>node1</code> and <code>node2</code> (in the same order if the edge is directed)
 or <code>null</code> otherwise.
 </p>
 <p>
 <p>
 In the case when the graph does not contain an edge with the same id, the
 method checks if <code>node1</code> and <code>node2</code> exist. If one or both of
 them do not exist, and strict checking is enabled, <code>
 ElementNotFoundException</code> is thrown. Otherwise if auto-creation is disabled,
 the method returns <code>null</code>. If auto-creation is enabled, the method
 creates the missing endpoints.
 <p>
 <p>
 When the edge id is not already in use and the both endpoints exist (or
 created), the edge can still be rejected. It may happen for example when it
 connects two already connected nodes in a single graph. If the edge is
 rejected, the method throws <code>EdgeRejectedException</code> if strict checking
 is enabled or returns <code>null</code> otherwise. Finally, if the edge is
 accepted, it is created using the corresponding edge factory and a reference
 to it is returned.
 <p>
 <p>
 An edge creation event is sent toward the listeners. If new nodes are
 created, the corresponding events are also sent to the listeners.
 </p>
 <p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>node1</code> - The first node identifier.</dd>
<dd><code>node2</code> - The second node identifier.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code> (see the
         detailed description above)</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If strict checking is enabled, and 'node1' or 'node2' are not
             registered in the graph.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)">addEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
java.lang.String&nbsp;from,
java.lang.String&nbsp;to,
boolean&nbsp;directed)</span>
              throws <span class="exceptions"><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a>, but this edge can be directed
 between the two given nodes. If directed, the edge goes in the 'from' -&gt;
 'to' direction. An event is sent toward the listeners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>from</code> - The first node identifier.</dd>
<dd><code>to</code> - The second node identifier.</dd>
<dd><code>directed</code> - Is the edge directed?</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code> (see the
         detailed description in <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a>)</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If strict checking is enabled, and 'node1' or 'node2' are not
             registered in the graph.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="stepBegins(double)">stepBegins</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">stepBegins</span>&#8203;(<span class="arguments">double&nbsp;time)</span></div>
<div class="block"><p>
 Since dynamic graphs are based on discrete event modifications, the notion of
 step is defined to simulate elapsed time between events. So a step is a event
 that occurs in the graph, it does not modify it but it gives a kind of
 timestamp that allows the tracking of the progress of the graph over the
 time.
 </p>
 <p>
 This kind of event is useful for dynamic algorithms that listen to the
 dynamic graph and need to measure the time in the graph's evolution.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>time</code> - A numerical value that may give a timestamp to track the evolution
            of the graph over the time.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="attributeSinks()">attributeSinks</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.Iterable&lt;<a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream">AttributeSink</a>&gt;</span>&nbsp;<span class="memberName">attributeSinks</span>()</div>
<div class="block">Returns an "iterable" of <a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream"><code>AttributeSink</code></a> objects registered to this
 graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the set of <a href="../stream/AttributeSink.html" title="interface in org.graphstream.stream"><code>AttributeSink</code></a> under the form of an iterable
         object.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="elementSinks()">elementSinks</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.Iterable&lt;<a href="../stream/ElementSink.html" title="interface in org.graphstream.stream">ElementSink</a>&gt;</span>&nbsp;<span class="memberName">elementSinks</span>()</div>
<div class="block">Returns an "iterable" of <a href="../stream/ElementSink.html" title="interface in org.graphstream.stream"><code>ElementSink</code></a> objects registered to this
 graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the list of <a href="../stream/ElementSink.html" title="interface in org.graphstream.stream"><code>ElementSink</code></a> under the form of an iterable object.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="read(java.lang.String)">read</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">read</span>&#8203;(<span class="arguments">java.lang.String&nbsp;filename)</span>
           throws <span class="exceptions">java.io.IOException,
<a href="../stream/GraphParseException.html" title="class in org.graphstream.stream">GraphParseException</a>,
<a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Utility method to read a graph. This method tries to identify the graph
 format by itself and instantiates the corresponding reader automatically. If
 this process fails, a NotFoundException is raised.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - The graph filename (or URL).</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If the file cannot be found or if the format is not recognized.</dd>
<dd><code><a href="../stream/GraphParseException.html" title="class in org.graphstream.stream">GraphParseException</a></code> - If there is a parsing error while reading the file.</dd>
<dd><code>java.io.IOException</code> - If an input output error occurs during the graph reading.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="read(org.graphstream.stream.file.FileSource,java.lang.String)">read</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">read</span>&#8203;(<span class="arguments"><a href="../stream/file/FileSource.html" title="interface in org.graphstream.stream.file">FileSource</a>&nbsp;input,
java.lang.String&nbsp;filename)</span>
           throws <span class="exceptions">java.io.IOException,
<a href="../stream/GraphParseException.html" title="class in org.graphstream.stream">GraphParseException</a></span></div>
<div class="block">Utility method to read a graph using the given reader.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>input</code> - An appropriate reader for the filename.</dd>
<dd><code>filename</code> - The graph filename (or URL).</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If the file cannot be found or if the format is not recognised.</dd>
<dd><code><a href="../stream/GraphParseException.html" title="class in org.graphstream.stream">GraphParseException</a></code> - If there is a parsing error while reading the file.</dd>
<dd><code>java.io.IOException</code> - If an input/output error occurs during the graph reading.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="write(java.lang.String)">write</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">write</span>&#8203;(<span class="arguments">java.lang.String&nbsp;filename)</span>
            throws <span class="exceptions">java.io.IOException</span></div>
<div class="block">Utility method to write a graph in DGS format to a file.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - The file that will contain the saved graph (or URL).</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - If an input/output error occurs during the graph writing.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="write(org.graphstream.stream.file.FileSink,java.lang.String)">write</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">write</span>&#8203;(<span class="arguments"><a href="../stream/file/FileSink.html" title="interface in org.graphstream.stream.file">FileSink</a>&nbsp;output,
java.lang.String&nbsp;filename)</span>
            throws <span class="exceptions">java.io.IOException</span></div>
<div class="block">Utility method to write a graph in the chosen format to a file.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - The file that will contain the saved graph (or URL).</dd>
<dd><code>output</code> - The output format to use.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - If an input/output error occurs during the graph writing.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="display()">display</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view">Viewer</a></span>&nbsp;<span class="memberName">display</span>()</div>
<div class="block">Utility method that creates a new graph viewer, and register the graph in it.
 Notice that this method is a quick way to see a graph, and only this. It can
 be used to prototype a program, but may be limited. This method automatically
 launch a graph layout algorithm in its own thread to compute best node
 positions.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a graph viewer that allows to command the viewer (it often run in
         another thread).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view"><code>Viewer</code></a>, 
<a href="#display(boolean)"><code>display(boolean )</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="display(boolean)">display</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view">Viewer</a></span>&nbsp;<span class="memberName">display</span>&#8203;(<span class="arguments">boolean&nbsp;autoLayout)</span></div>
<div class="block">Utility method that creates a new graph viewer, and register the graph in it.
 Notice that this method is a quick way to see a graph, and only this. It can
 be used to prototype a program, but is very limited.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>autoLayout</code> - If true a layout algorithm is launched in its own thread to
            compute best node positions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a graph viewer that allows to command the viewer (it often run in
         another thread).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../ui/view/Viewer.html" title="class in org.graphstream.ui.view"><code>Viewer</code></a>, 
<a href="#display()"><code>display()</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getNode(int)">getNode</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">getNode</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
      throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Get a node by its index. This method is implicitly generic and returns
 something which extends Node. The return type is the one of the left part of
 the assignment. For example, in the following call :
 <p>
 
 <pre>
 ExtendedNode node = graph.getNode(index);
 </pre>
 <p>
 the method will return an ExtendedNode node. If no left part exists, method
 will just return a Node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of the node to find.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The node with the given index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If the index is negative or greater than <code>
                                   getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdge(int)">getEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdge</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
      throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Get an edge by its index. This method is implicitly generic and returns
 something which extends Edge. The return type is the one of the left part of
 the assignment. For example, in the following call :
 <p>
 
 <pre>
 ExtendedEdge edge = graph.getEdge(index);
 </pre>
 <p>
 the method will return an ExtendedEdge edge. If no left part exists, method
 will just return an Edge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the edge to find.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The edge with the given index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is less than 0 or greater than <code>
                                   getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,int,int)">addEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
int&nbsp;index1,
int&nbsp;index2)</span>
              throws <span class="exceptions">java.lang.IndexOutOfBoundsException,
<a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a> but the nodes are identified by
 their indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>index1</code> - The first node index</dd>
<dd><code>index2</code> - The second node index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If node indices are negative or greater than <code>
                                   getNodeCount() - 1</code></dd>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,int,int,boolean)">addEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
int&nbsp;fromIndex,
int&nbsp;toIndex,
boolean&nbsp;directed)</span>
              throws <span class="exceptions">java.lang.IndexOutOfBoundsException,
<a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)"><code>addEdge(String, String, String, boolean)</code></a> but the nodes are
 identified by their indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>toIndex</code> - The first node index</dd>
<dd><code>fromIndex</code> - The second node index</dd>
<dd><code>directed</code> - Is the edge directed?</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If node indices are negative or greater than <code>
                                   getNodeCount() - 1</code></dd>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,org.graphstream.graph.Node,org.graphstream.graph.Node)">addEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node1,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node2)</span>
              throws <span class="exceptions"><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a> but the node references are
 given instead of node identifiers.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>node1</code> - The first node</dd>
<dd><code>node2</code> - The second node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="addEdge(java.lang.String,org.graphstream.graph.Node,org.graphstream.graph.Node,boolean)">addEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">addEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;from,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;to,
boolean&nbsp;directed)</span>
      throws <span class="exceptions"><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a>,
<a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></span></div>
<div class="block">Like <a href="#addEdge(java.lang.String,java.lang.String,java.lang.String,boolean)"><code>addEdge(String, String, String, boolean)</code></a> but the node
 references are given instead of node identifiers.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Unique and arbitrary string identifying the edge.</dd>
<dd><code>from</code> - The first node</dd>
<dd><code>to</code> - The second node</dd>
<dd><code>directed</code> - Is the edge directed?</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newly created edge, an existing edge or <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="IdAlreadyInUseException.html" title="class in org.graphstream.graph">IdAlreadyInUseException</a></code> - If an edge with the same id already exists and strict checking is
             enabled.</dd>
<dd><code><a href="EdgeRejectedException.html" title="class in org.graphstream.graph">EdgeRejectedException</a></code> - If strict checking is enabled and the edge is not accepted.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addEdge(java.lang.String,java.lang.String,java.lang.String)"><code>addEdge(String, String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(int)">removeEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
                 throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Removes an edge with a given index. An event is sent toward the listeners.
 <p>
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedEdge edge = graph.removeEdge(i);
 </pre>
 <p>
 the method will return an ExtendedEdge edge. If no left part exists, method
 will just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the edge to be removed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed edge</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
                                   getEdgeCount() - 1</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(int,int)">removeEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments">int&nbsp;fromIndex,
int&nbsp;toIndex)</span>
                 throws <span class="exceptions">java.lang.IndexOutOfBoundsException,
<a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Removes an edge between two nodes. Like <a href="#removeEdge(java.lang.String,java.lang.String)"><code>removeEdge(String, String)</code></a>
 but the nodes are identified by their indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fromIndex</code> - the index of the source node</dd>
<dd><code>toIndex</code> - the index of the target node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the removed edge or <code>null</code> if no edge is removed</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If one of the node indices is negative or greater than
             <code>getNodeCount() - 1</code>.</dd>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - if strict checking is enabled and there is no edge between the
             two nodes.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#removeEdge(java.lang.String,java.lang.String)"><code>removeEdge(String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(org.graphstream.graph.Node,org.graphstream.graph.Node)">removeEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node1,
<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node2)</span>
         throws <span class="exceptions"><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Removes an edge between two nodes. Like <a href="#removeEdge(java.lang.String,java.lang.String)"><code>removeEdge(String, String)</code></a>
 but node references are given instead of node identifiers.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node1</code> - the first node</dd>
<dd><code>node2</code> - the second node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the removed edge or <code>null</code> if no edge is removed</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - if strict checking is enabled and there is no edge between the
             two nodes.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#removeEdge(java.lang.String,java.lang.String)"><code>removeEdge(String, String)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(java.lang.String,java.lang.String)">removeEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;from,
java.lang.String&nbsp;to)</span>
                 throws <span class="exceptions"><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Remove an edge given the identifiers of its two endpoints.
 <p>
 If the edge is directed it is removed only if its source and destination
 nodes are identified by 'from' and 'to' respectively. If the graph is a
 multi-graph and there are several edges between the two nodes, one of the
 edges at random is removed. An event is sent toward the listeners. If strict
 checking is enabled and at least one of the two given nodes does not exist or
 if they are not connected, a not found exception is raised. Else the error is
 silently ignored, and null is returned.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - The origin node identifier to select the edge.</dd>
<dd><code>to</code> - The destination node identifier to select the edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed edge, or null if strict checking is disabled and at least
         one of the two given nodes does not exist or there is no edge between
         them</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If the 'from' or 'to' node is not registered in the graph or not
             connected and strict checking is enabled.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(java.lang.String)">removeEdge</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span>
                 throws <span class="exceptions"><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Removes an edge knowing its identifier. An event is sent toward the
 listeners. If strict checking is enabled and the edge does not exist,
 <code>ElementNotFoundException</code> is raised. Otherwise the error is silently
 ignored and null is returned.
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedEdge e = graph.removeEdge(&quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the edge to remove.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed edge, or null if strict checking is disabled and the edge
         does not exist.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If no edge matches the identifier and strict checking is enabled.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeEdge(org.graphstream.graph.Edge)">removeEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">removeEdge</span>&#8203;(<span class="arguments"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&nbsp;edge)</span></div>
<div class="block">Removes an edge. An event is sent toward the listeners.
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedEdge e = graph.removeEdge(...);
 </pre>
 <p>
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>edge</code> - The edge to be removed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed edge</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeNode(int)">removeNode</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">removeNode</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
                 throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Removes a node with a given index.
 <p>
 An event is generated toward the listeners. Note that removing a node may
 remove all edges it is connected to. In this case corresponding events will
 also be generated toward the listeners.
 </p>
 <p>
 This method is implicitly generic and return something which extends Node.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedNode n = graph.removeNode(index);
 </pre>
 <p>
 the method will return an ExtendedNode. If no left part exists, method will
 just return a Node.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the node to be removed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed node</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
                                   getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeNode(java.lang.String)">removeNode</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">removeNode</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span>
                 throws <span class="exceptions"><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></span></div>
<div class="block">Remove a node using its identifier.
 <p>
 An event is generated toward the listeners. Note that removing a node may
 remove all edges it is connected to. In this case corresponding events will
 also be generated toward the listeners.
 </p>
 <p>
 This method is implicitly generic and return something which extends Node.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedNode n = graph.removeNode(&quot;...&quot;);
 </pre>
 <p>
 the method will return an ExtendedNode. If no left part exists, method will
 just return a Node.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - The unique identifier of the node to remove.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed node. If strict checking is disabled, it can return null
         if the node to remove does not exist.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ElementNotFoundException.html" title="class in org.graphstream.graph">ElementNotFoundException</a></code> - If no node matches the given identifier and strict checking is
             enabled.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="removeNode(org.graphstream.graph.Node)">removeNode</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Node.html" title="interface in org.graphstream.graph">Node</a></span>&nbsp;<span class="memberName">removeNode</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">Removes a node.
 <p>
 An event is generated toward the listeners. Note that removing a node may
 remove all edges it is connected to. In this case corresponding events will
 also be generated toward the listeners.
 </p>
 <p>
 This method is implicitly generic and return something which extends Node.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 <p>
 
 <pre>
 ExtendedNode n = graph.removeNode(...);
 </pre>
 <p>
 the method will return an ExtendedNode. If no left part exists, method will
 just return a Node.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to be removed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removed node</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Graph.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
