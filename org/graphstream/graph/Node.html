<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc (13.0.1) on Wed Jul 15 10:47:57 CEST 2020 -->
<title>Node</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2020-07-15">
<meta name="description" content="declaration: package: org.graphstream.graph, interface: Node">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":6,"i1":18,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":18,"i23":18,"i24":18,"i25":18,"i26":18,"i27":18,"i28":18,"i29":18,"i30":18,"i31":18,"i32":18,"i33":18,"i34":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Node.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.graphstream.graph</a></div>
<h1 title="Interface Node" class="title">Interface Node</h1>
</div>
<div class="contentContainer">
<section class="description">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="Element.html" title="interface in org.graphstream.graph">Element</a></code>, <code>java.lang.Iterable&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="implementations/AbstractNode.html" title="class in org.graphstream.graph.implementations">AbstractNode</a></code>, <code><a href="implementations/AdjacencyListNode.html" title="class in org.graphstream.graph.implementations">AdjacencyListNode</a></code>, <code><a href="../ui/graphicGraph/GraphicNode.html" title="class in org.graphstream.ui.graphicGraph">GraphicNode</a></code>, <code><a href="implementations/MultiNode.html" title="class in org.graphstream.graph.implementations">MultiNode</a></code>, <code><a href="implementations/SingleNode.html" title="class in org.graphstream.graph.implementations">SingleNode</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">Node</span>
extends <a href="Element.html" title="interface in org.graphstream.graph">Element</a>, java.lang.Iterable&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</pre>
<div class="block">An Interface that advises general purpose methods for handling nodes as
 elements of a graph.
 
 <h3>Important</h3>
 <p>
 Implementing classes should indicate the complexity of their implementation
 for each method.
 </p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>July 12 2007</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="tableTab" onclick="show(16);">Default Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#edges()">edges</a></span>()</code></th>
<td class="colLast">
<div class="block">Stream over all entering and leaving edges.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>default java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#enteringEdges()">enteringEdges</a></span>()</code></th>
<td class="colLast">
<div class="block">Stream over all entering edges.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBreadthFirstIterator()">getBreadthFirstIterator</a></span>()</code></th>
<td class="colLast">
<div class="block">Iterator for breadth first exploration of the graph, starting at this node.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBreadthFirstIterator(boolean)">getBreadthFirstIterator</a></span>&#8203;(boolean&nbsp;directed)</code></th>
<td class="colLast">
<div class="block">Iterator for breadth first exploration of the graph, starting at this node.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDegree()">getDegree</a></span>()</code></th>
<td class="colLast">
<div class="block">Total number of relations with other nodes or this node.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDepthFirstIterator()">getDepthFirstIterator</a></span>()</code></th>
<td class="colLast">
<div class="block">Iterator for depth first exploration of the graph, starting at this node.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDepthFirstIterator(boolean)">getDepthFirstIterator</a></span>&#8203;(boolean&nbsp;directed)</code></th>
<td class="colLast">
<div class="block">Iterator for depth first exploration of the graph, starting at this node.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdge(int)">getEdge</a></span>&#8203;(int&nbsp;i)</code></th>
<td class="colLast">
<div class="block">I-th edge.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeBetween(int)">getEdgeBetween</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge between this node and the node with index i if one exists.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeBetween(java.lang.String)">getEdgeBetween</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Retrieve an edge between this node and the node 'id', if it exits.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeBetween(org.graphstream.graph.Node)">getEdgeBetween</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge between this node and and another node if one exists.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeFrom(int)">getEdgeFrom</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge that leaves node with given index toward this node.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeFrom(java.lang.String)">getEdgeFrom</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Retrieve an edge that leaves node 'id' toward this node.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeFrom(org.graphstream.graph.Node)">getEdgeFrom</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge that leaves given node toward this node.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeToward(int)">getEdgeToward</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge that leaves this node toward the node with given index.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeToward(java.lang.String)">getEdgeToward</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Retrieve an edge that leaves this node toward 'id'.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEdgeToward(org.graphstream.graph.Node)">getEdgeToward</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Retrieves an edge that leaves this node toward another node.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEnteringEdge(int)">getEnteringEdge</a></span>&#8203;(int&nbsp;i)</code></th>
<td class="colLast">
<div class="block">I-th entering edge.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code><a href="Graph.html" title="interface in org.graphstream.graph">Graph</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGraph()">getGraph</a></span>()</code></th>
<td class="colLast">
<div class="block">Parent graph.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInDegree()">getInDegree</a></span>()</code></th>
<td class="colLast">
<div class="block">Number of entering edges.</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLeavingEdge(int)">getLeavingEdge</a></span>&#8203;(int&nbsp;i)</code></th>
<td class="colLast">
<div class="block">I-th leaving edge.</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getOutDegree()">getOutDegree</a></span>()</code></th>
<td class="colLast">
<div class="block">Number of leaving edges.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeBetween(int)">hasEdgeBetween</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">True if an edge exists between this node and a node with given index.</div>
</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeBetween(java.lang.String)">hasEdgeBetween</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">True if an edge exists between this node and node 'id'.</div>
</td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeBetween(org.graphstream.graph.Node)">hasEdgeBetween</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">True if an edge exists between this node and another node.</div>
</td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeFrom(int)">hasEdgeFrom</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">True if an edge enters this node from a node with given index.</div>
</td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeFrom(java.lang.String)">hasEdgeFrom</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">True if an edge enters this node from node 'id'.</div>
</td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeFrom(org.graphstream.graph.Node)">hasEdgeFrom</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">True if an edge enters this node from a given node.</div>
</td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeToward(int)">hasEdgeToward</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">True if an edge leaves this node toward a node with given index.</div>
</td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeToward(java.lang.String)">hasEdgeToward</a></span>&#8203;(java.lang.String&nbsp;id)</code></th>
<td class="colLast">
<div class="block">True if an edge leaves this node toward node 'id'.</div>
</td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>default boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasEdgeToward(org.graphstream.graph.Node)">hasEdgeToward</a></span>&#8203;(<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</code></th>
<td class="colLast">
<div class="block">True if an edge leaves this node toward a given node.</div>
</td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>default java.util.Iterator&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterator()">iterator</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>default java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#leavingEdges()">leavingEdges</a></span>()</code></th>
<td class="colLast">
<div class="block">Stream over all leaving edges.</div>
</td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>default java.util.stream.Stream&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#neighborNodes()">neighborNodes</a></span>()</code></th>
<td class="colLast">
<div class="block">Stream over neighbor nodes connected to this node via one or more edges.</div>
</td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Override the Object.toString() method.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;org.graphstream.graph.<a href="Element.html" title="interface in org.graphstream.graph">Element</a></h3>
<a id="methods.inherited.from.class.org.graphstream.graph.Element">
<!--   -->
</a><code><a href="Element.html#attributeKeys()">attributeKeys</a>, <a href="Element.html#clearAttributes()">clearAttributes</a>, <a href="Element.html#getArray(java.lang.String)">getArray</a>, <a href="Element.html#getAttribute(java.lang.String)">getAttribute</a>, <a href="Element.html#getAttribute(java.lang.String,java.lang.Class)">getAttribute</a>, <a href="Element.html#getAttributeCount()">getAttributeCount</a>, <a href="Element.html#getFirstAttributeOf(java.lang.Class,java.lang.String...)">getFirstAttributeOf</a>, <a href="Element.html#getFirstAttributeOf(java.lang.String...)">getFirstAttributeOf</a>, <a href="Element.html#getId()">getId</a>, <a href="Element.html#getIndex()">getIndex</a>, <a href="Element.html#getLabel(java.lang.String)">getLabel</a>, <a href="Element.html#getMap(java.lang.String)">getMap</a>, <a href="Element.html#getNumber(java.lang.String)">getNumber</a>, <a href="Element.html#getVector(java.lang.String)">getVector</a>, <a href="Element.html#hasArray(java.lang.String)">hasArray</a>, <a href="Element.html#hasAttribute(java.lang.String)">hasAttribute</a>, <a href="Element.html#hasAttribute(java.lang.String,java.lang.Class)">hasAttribute</a>, <a href="Element.html#hasLabel(java.lang.String)">hasLabel</a>, <a href="Element.html#hasMap(java.lang.String)">hasMap</a>, <a href="Element.html#hasNumber(java.lang.String)">hasNumber</a>, <a href="Element.html#hasVector(java.lang.String)">hasVector</a>, <a href="Element.html#removeAttribute(java.lang.String)">removeAttribute</a>, <a href="Element.html#setAttribute(java.lang.String,java.lang.Object...)">setAttribute</a>, <a href="Element.html#setAttributes(java.util.Map)">setAttributes</a></code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;java.lang.Iterable</h3>
<a id="methods.inherited.from.class.java.lang.Iterable">
<!--   -->
</a><code>forEach, spliterator</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="getGraph()">getGraph</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Graph.html" title="interface in org.graphstream.graph">Graph</a></span>&nbsp;<span class="memberName">getGraph</span>()</div>
<div class="block">Parent graph. Some elements are not able to give their parent graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The graph containing this node or null if unknown.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getDegree()">getDegree</a></h3>
<div class="memberSignature"><span class="returnType">int</span>&nbsp;<span class="memberName">getDegree</span>()</div>
<div class="block">Total number of relations with other nodes or this node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of edges/relations/links.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getOutDegree()">getOutDegree</a></h3>
<div class="memberSignature"><span class="returnType">int</span>&nbsp;<span class="memberName">getOutDegree</span>()</div>
<div class="block">Number of leaving edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of edges that only leave this node plus all undirected
         edges.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getInDegree()">getInDegree</a></h3>
<div class="memberSignature"><span class="returnType">int</span>&nbsp;<span class="memberName">getInDegree</span>()</div>
<div class="block">Number of entering edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of edges that only enter this node plus all undirected
         edges.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeToward(java.lang.String)">getEdgeToward</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeToward</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">Retrieve an edge that leaves this node toward 'id'.
 <p>
 This method selects only edges leaving this node an pointing at node 'id'
 (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeToward(&quot;...&quot;);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from this node to 'id', or undirected edge if it
         exists, else null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeFrom(java.lang.String)">getEdgeFrom</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeFrom</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">Retrieve an edge that leaves node 'id' toward this node.
 <p>
 This method selects only edges leaving node 'id' an pointing at this node
 (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from node 'id' to this node, or undirected edge
         if it exists, else null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeBetween(java.lang.String)">getEdgeBetween</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeBetween</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">Retrieve an edge between this node and the node 'id', if it exits.
 <p>
 This method selects directed or undirected edges. If the edge is directed,
 its direction is not important and leaving or entering edges will be
 selected.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeBetween(&quot;...&quot;);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the opposite node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Edge between node 'id' and this node if it exists, else null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="neighborNodes()">neighborNodes</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.stream.Stream&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">neighborNodes</span>()</div>
<div class="block">Stream over neighbor nodes connected to this node via one or more edges. This
 iterator iterates across any leaving, entering and non directed edges (nodes
 are neighbors even if they only have a directed edge from them toward this
 node). If there are multiple edges connecting the same node, it might be
 iterated several times.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The stream, neighbors are streamed in arbitrary order.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdge(int)">getEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdge</span>&#8203;(<span class="arguments">int&nbsp;i)</span></div>
<div class="block">I-th edge. Edges are stored in no given order.
 <p>
 However this method allows to iterate very quickly on all edges, or to choose
 a given edge with direct access.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdge(i);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - Index of the edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The i-th edge.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if <code>i</code> is negative or greater than or equal to the
             degree</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEnteringEdge(int)">getEnteringEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEnteringEdge</span>&#8203;(<span class="arguments">int&nbsp;i)</span></div>
<div class="block">I-th entering edge. Edges are stored in no given order.
 <p>
 However this method allows to iterate very quickly on all entering edges, or
 to choose a given entering edge with direct access.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEnteringEdge(i);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - Index of the edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The i-th entering edge.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if <code>i</code> is negative or greater than or equal to the
             in-degree</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getLeavingEdge(int)">getLeavingEdge</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getLeavingEdge</span>&#8203;(<span class="arguments">int&nbsp;i)</span></div>
<div class="block">I-th leaving edge. Edges are stored in no given order.
 <p>
 However this method allows to iterate very quickly on all leaving edges, or
 to choose a given leaving edge with direct access.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getLeavingEdge(i);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - Index of the edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The i-th leaving edge.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>IndexOutOfBoundException</code> - if <code>i</code> is negative or greater than or equal to the
             out-degree</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getBreadthFirstIterator()">getBreadthFirstIterator</a></h3>
<div class="memberSignature"><span class="returnType">java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">getBreadthFirstIterator</span>()</div>
<div class="block">Iterator for breadth first exploration of the graph, starting at this node.
 <p>
 If the graph is not connected, only a part of it will be explored. By
 default, this iterator will respect edge orientation.
 </p>
 <p>
 This method is implicitly generic and return an Iterator over something which
 extends Node. The return type is the one of the left part of the assignment.
 For example, in the following call :
 
 <pre>
 Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator();
 </pre>
 
 the method will return an Iterator&lt;ExtendedNode&gt;. If no left part
 exists, method will just return an Iterator&lt;Node&gt;.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator able to explore the graph in a breadth first way starting
         at this node.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getBreadthFirstIterator(boolean)">getBreadthFirstIterator</a></h3>
<div class="memberSignature"><span class="returnType">java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">getBreadthFirstIterator</span>&#8203;(<span class="arguments">boolean&nbsp;directed)</span></div>
<div class="block">Iterator for breadth first exploration of the graph, starting at this node.
 <p>
 If the graph is not connected, only a part of it will be explored.
 </p>
 <p>
 This method is implicitly generic and return an Iterator over something which
 extends Node. The return type is the one of the left part of the assignment.
 For example, in the following call :
 
 <pre>
 Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator(true);
 </pre>
 
 the method will return an Iterator&lt;ExtendedNode&gt;. If no left part
 exists, method will just return an Iterator&lt;Node&gt;.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>directed</code> - If false, the iterator will ignore edge orientation (the default
            is "True").</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator able to explore the graph in a breadth first way starting
         at this node.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getDepthFirstIterator()">getDepthFirstIterator</a></h3>
<div class="memberSignature"><span class="returnType">java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">getDepthFirstIterator</span>()</div>
<div class="block">Iterator for depth first exploration of the graph, starting at this node.
 <p>
 If the graph is not connected, only a part of it will be explored. By
 default, this iterator will respect edge orientation.
 </p>
 <p>
 This method is implicitly generic and return an Iterator over something which
 extends Node. The return type is the one of the left part of the assignment.
 For example, in the following call :
 
 <pre>
 Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator();
 </pre>
 
 the method will return an Iterator&lt;ExtendedNode&gt;. If no left part
 exists, method will just return an Iterator&lt;Node&gt;.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator able to explore the graph in a depth first way starting
         at this node.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getDepthFirstIterator(boolean)">getDepthFirstIterator</a></h3>
<div class="memberSignature"><span class="returnType">java.util.Iterator&lt;<a href="Node.html" title="interface in org.graphstream.graph">Node</a>&gt;</span>&nbsp;<span class="memberName">getDepthFirstIterator</span>&#8203;(<span class="arguments">boolean&nbsp;directed)</span></div>
<div class="block">Iterator for depth first exploration of the graph, starting at this node.
 <p>
 If the graph is not connected, only a part of it will be explored.
 </p>
 <p>
 This method is implicitly generic and return an Iterator over something which
 extends Node. The return type is the one of the left part of the assignment.
 For example, in the following call :
 
 <pre>
 Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator(true);
 </pre>
 
 the method will return an Iterator&lt;ExtendedNode&gt;. If no left part
 exists, method will just return an Iterator&lt;Node&gt;.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>directed</code> - If false, the iterator will ignore edge orientation (the default
            is "True").</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator able to explore the graph in a depth first way starting
         at this node.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="edges()">edges</a></h3>
<div class="memberSignature"><span class="returnType">java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</span>&nbsp;<span class="memberName">edges</span>()</div>
<div class="block">Stream over all entering and leaving edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A stream over all directed and undirected edges, leaving or entering.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="leavingEdges()">leavingEdges</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</span>&nbsp;<span class="memberName">leavingEdges</span>()</div>
<div class="block">Stream over all leaving edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A stream over only edges that leave this node plus all undirected
         edges.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="enteringEdges()">enteringEdges</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.stream.Stream&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</span>&nbsp;<span class="memberName">enteringEdges</span>()</div>
<div class="block">Stream over all entering edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A stream over only edges that enter this node plus all undirected
         edges.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="iterator()">iterator</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.Iterator&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</span>&nbsp;<span class="memberName">iterator</span>()</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>iterator</code>&nbsp;in interface&nbsp;<code>java.lang.Iterable&lt;<a href="Edge.html" title="interface in org.graphstream.graph">Edge</a>&gt;</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="toString()">toString</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">toString</span>()</div>
<div class="block">Override the Object.toString() method.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeToward(java.lang.String)">hasEdgeToward</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeToward</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">True if an edge leaves this node toward node 'id'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from this node to 'id' or if an
         undirected edge exists.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeToward(org.graphstream.graph.Node)">hasEdgeToward</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeToward</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">True if an edge leaves this node toward a given node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from this node to the other node or if
         an undirected edge exists.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeToward(int)">hasEdgeToward</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeToward</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
                       throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">True if an edge leaves this node toward a node with given index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of the target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from this node to the other node or if
         an undirected edge exists.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeFrom(java.lang.String)">hasEdgeFrom</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeFrom</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">True if an edge enters this node from node 'id'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of the source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from this node to 'id' or if an
         undirected edge exists.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeFrom(org.graphstream.graph.Node)">hasEdgeFrom</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeFrom</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">True if an edge enters this node from a given node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from the other node to this node or if
         an undirected edge exists.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeFrom(int)">hasEdgeFrom</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeFrom</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
                     throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">True if an edge enters this node from a node with given index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of the source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a directed edge goes from the other node to this node or if
         an undirected edge exists.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeBetween(java.lang.String)">hasEdgeBetween</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeBetween</span>&#8203;(<span class="arguments">java.lang.String&nbsp;id)</span></div>
<div class="block">True if an edge exists between this node and node 'id'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - Identifier of another node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if a edge exists between this node and node 'id'.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeBetween(org.graphstream.graph.Node)">hasEdgeBetween</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeBetween</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">True if an edge exists between this node and another node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - Another node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if an edge exists between this node and the other node.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hasEdgeBetween(int)">hasEdgeBetween</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">hasEdgeBetween</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
                        throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">True if an edge exists between this node and a node with given index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of another node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if an edge exists between this node and the other node.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeToward(org.graphstream.graph.Node)">getEdgeToward</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeToward</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">Retrieves an edge that leaves this node toward another node.
 <p>
 This method selects only edges leaving this node an pointing at the parameter
 node (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeToward(...);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from this node to the parameter node, or
         undirected edge if it exists, else null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeToward(int)">getEdgeToward</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeToward</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
            throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Retrieves an edge that leaves this node toward the node with given index.
 <p>
 This method selects only edges leaving this node an pointing at the parameter
 node (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeToward(...);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of the target node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from this node to the parameter node, or
         undirected edge if it exists, else null.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeFrom(org.graphstream.graph.Node)">getEdgeFrom</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeFrom</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">Retrieves an edge that leaves given node toward this node.
 <p>
 This method selects only edges leaving the other node an pointing at this
 node (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeFrom(...);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from the parameter node to this node, or
         undirected edge if it exists, else null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeFrom(int)">getEdgeFrom</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeFrom</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
          throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Retrieves an edge that leaves node with given index toward this node.
 <p>
 This method selects only edges leaving the other node an pointing at this
 node (this also selects undirected edges).
 </p>
 <p>
 This method is implicitly generic and returns something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - Index of the source node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Directed edge going from the parameter node to this node, or
         undirected edge if it exists, else null.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeBetween(org.graphstream.graph.Node)">getEdgeBetween</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeBetween</span>&#8203;(<span class="arguments"><a href="Node.html" title="interface in org.graphstream.graph">Node</a>&nbsp;node)</span></div>
<div class="block">Retrieves an edge between this node and and another node if one exists.
 <p>
 This method selects directed or undirected edges. If the edge is directed,
 its direction is not important and leaving or entering edges will be
 selected.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeBetween(...);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The opposite node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Edge between this node and the parameter node if it exists, else
         null.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getEdgeBetween(int)">getEdgeBetween</a></h3>
<div class="memberSignature"><span class="returnType"><a href="Edge.html" title="interface in org.graphstream.graph">Edge</a></span>&nbsp;<span class="memberName">getEdgeBetween</span>&#8203;(<span class="arguments">int&nbsp;index)</span>
             throws <span class="exceptions">java.lang.IndexOutOfBoundsException</span></div>
<div class="block">Retrieves an edge between this node and the node with index i if one exists.
 <p>
 This method selects directed or undirected edges. If the edge is directed,
 its direction is not important and leaving or entering edges will be
 selected.
 </p>
 <p>
 This method is implicitly generic and return something which extends Edge.
 The return type is the one of the left part of the assignment. For example,
 in the following call :
 
 <pre>
 ExtendedEdge e = node.getEdgeBetween(...);
 </pre>
 
 the method will return an ExtendedEdge. If no left part exists, method will
 just return an Edge.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the opposite node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Edge between node with index i and this node if it exists, else null.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is negative or greater than <code>
             getNodeCount() - 1</code>.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Node.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
